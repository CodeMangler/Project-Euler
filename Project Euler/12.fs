#light

(*
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
*)

// Sum of first n natural numbers
let triangle_number (n:bigint) = 
    (n * (n + 1I)) / 2I ;;

// Sloow (for large n of course..)
let divisors (n:bigint) =
    let rec divisor_loop (i:bigint) (a_list:bigint list) = 
        if (i = 1I) then
            (i :: a_list)
        else if ((n % i) = 0I) then
            (divisor_loop (i - 1I) (i :: a_list))
        else
            (divisor_loop (i - 1I) a_list)
    
    (divisor_loop (n / 2I) [n;])
    ;;

let divides (n:bigint) (i:bigint) =
    n % i = 0I;;

let is_prime (n:bigint) =
    let rec prime_check_loop (i:bigint) = 
        ( i > (n / 2I) ) || ((not (i |> divides n)) && prime_check_loop (i + 1I))
    
    prime_check_loop 2I;;
    
let rec prime_factors (n:bigint) (factors:bigint list) =
    if (is_prime n) then
        n :: factors
    else
        let mutable i:bigint = 2I;
        while (n % i <> 0I) && (i <= n/2I) do
            i <- i + 1I
        done
        
        if( i <= n/2I) then
            factors @ (prime_factors i factors) @ (prime_factors (n / i) factors)
        else
            []
;;

open System.Collections.Generic

let prime_factor_map (factors:bigint list) =
    let factor_map = Dictionary<bigint, bigint>()
    
    for factor in factors do
        if (factor_map.ContainsKey(factor)) then
            factor_map.[factor] <- (factor_map.[factor] + 1I)
        else
            factor_map.Add(factor, 1I)
    done
    
    factor_map;;

// Calculating the number of divisors: http://www.algebra-online.com/positive-integral-divisors-1.htm
let number_of_divisors (n:bigint) =
    let factor_map = (prime_factors n []) |> prime_factor_map
    let exponents = factor_map.Values
    let mutable divisor_count = 1I
    
    for exponent in exponents do
        divisor_count <- (divisor_count * (exponent + 1I))
    done
    
    divisor_count
    ;;

let triangle_number_search (minimum_divisor_count:bigint) =
    let mutable keep_searching = true
    let mutable next = 1I
    let mutable n = (triangle_number next)
    
    while keep_searching do
        let divisor_count = (number_of_divisors n)
        if (divisor_count < minimum_divisor_count) then
            next <- next + 1I
            n <- (triangle_number next)
        else
            keep_searching <- false
    done
    n
    ;;

// Correct answer: 76576500I i.e. 76576500
// (triangle_number_search 500I);; = 76576500I  [It takes a little less than a minute to calculate.. Can definitely be improved..]
// Just for curiosity: (number_of_divisors 76576500I);; = 576I
// and (prime_factors 76576500I []);; = [2I; 2I; 3I; 3I; 5I; 5I; 5I; 7I; 11I; 13I; 17I]
